struct fst_version_t {
    uint8_t major;
    uint8_t minor;
    uint8_t patch;
};
typedef struct fst_version_t fst_version_t;

/* EE stands for Engine Event. */

struct fst_extension_t {
    fst_version_t version; /* <- Required to allow for multiple versions of an extension to be present. */
    fst_version_t engine_version;
    const uint8_t *name; /* <- Acts as an identifier. */
    const uint8_t *info; /* <- Put some more info for the user. */
    void (*ee_handler)(const fst_ee_event*);
};
typedef struct fst_extension_t fst_extension_t;


fst_ext_<name>.dll

/* Custom part */

/* All functions except your event handler should be marked static. */

uint32_t my_extension_id;

void handler_or_whatever(const fst_ee_event *e) {
    switch(e->type) {
    case FST_EE_EXTENSION_LOADED:
        /*
         * This event is sent to an extension right after it is loaded.
         *
         * This is where it all begins, and the engine has already decided 
         * if your extension is compatible or not with it.
         * See e->extension_loaded->handle; if handle is NULL, then
         * it is not compatible.
         * An extension handle may be as simple as an array index or a hash 
         * of its name and version.
         * 
         * If it is not compatible, here is your opportunity to alert the user,
         * because you will receive no more events (not even 
         * FST_EE_EXTENSION_UNLOADED) and get unloaded right after this 
         * function returns.
         * 
         * Otherwise, go on happily by initializing your extension here, and
         * don't forget to set its event mask.
         * fst_ee_mask(extension_handle, <mask>);
         * watchd = fst_ee_add_watch(extension_handle, <path_no_wildcards>, 
         *                           <event_mask>);
         * fst_ee_rm_watch(extension_id, <watchd>);
         * Telling the engine which events you want and don't want is important
         * because we care about in-game performance. 
         * By default, your event mask is only set to FST_EE_EXTENSION_UNLOAD.
         */
        break;
    case FST_EE_EXTENSION_UNLOAD:
        /*
         * This event is sent to an extension right before it is unloaded 
         * (given it was compatible with the engine).
         * Please be nice and clean-up your stuff here.
         */
        break;
    case FST_EE_ALL_EXTENSIONS_LOADED:
        /* 
         * The engine is done loading all the extensions it could find. 
         * Subscribe to this event if you want to interact with other 
         * extensions.
         */
        break;
    case FST_EE_CUSTOM:
        /*
         * It is never actually sent by the engine, but it is there for events 
         * provided by extensions themselves. That way, extensions can 
         * communicate between them. 
         * One should use it like so :
         * 
         * fst_extension_t *receiver; <- Of course, don't let it at NULL.
         * your_data_t your_data; <- Your own struct, for example.
         * fst_ee_event e;
         * e.type = FST_EE_CUSTOM;
         * e.custom = &your_data;
         * receiver->ee_handler(&e);
         *
         * Then the receiving extension is responsible for handling the data in 
         * e.custom. You can put anything in it, like your extension 
         * itself, the data's length, etc. However, it is your responsibility.
         */
        break;

    case FST_EE_NODE_LINKED:  /* After ++links_count or creation */
    case FST_EE_NODE_UNLINK: /* Before --links_count or deletion */
    case FST_EE_NODE_PRE_READ:  /* Before reading */
    case FST_EE_NODE_POST_READ:  /* After reading */
    case FST_EE_NODE_PRE_WRITE: /* Before writing (also provides new value) */
    case FST_EE_NODE_POST_WRITE: /* After writing (also provides old value) */
    case FST_EE_NODE_RENAME: /* Before renaming */
    case FST_EE_NODE_RENAMED: /* After renaming */
    /* 
     * Since all of the engine's services are available as nodes, there is 
     * no need for more event types.
     * Please note that you should also use the above to watch for 
     * video/audio backend changes. 
     * The user's not gonna be happy if you call a GL function whereas the
     * current video backend is Vulkan and there is no OpenGL context.
     * In the same way, it is your responsibility to make sure that the 
     * backend's functions you reach for are compatible with its version.
     * Don't call glShaderBinary() while the supported OpenGL version is 1.1 !
     * In such cases, your extension should just do nothing instead.
     */
    }
}

/* Required part */

const fst_extension_t FST_EXT_<NAME> = {
    {1,0,0},
    {1,0,0},
    <name>,
    "<name>, written by <author>. More info here as you wish.",
    &handler_or_whatever
};
